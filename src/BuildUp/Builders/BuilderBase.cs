using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

namespace BuildUp.Builders
{
	/// <summary>
	/// Base class for typical *Builder classes (CustomerBuilder, OrderBuilder) that allow test code to vary values used
	/// to create the objects via chainable methods, e.g. new OrderBuilder().WithCustomer( ...). In some projects, builder 
	/// classes will be the most suitable place to locate methods that are used to vary parameters used to construct the objects.
	/// This base class provides some convenience methods to make these chainable methods simple to write. It includes helper
	/// methods to support immutable and mutable builders.
	/// </summary>
	/// <typeparam name="TObject">The type of object generated by the builder</typeparam>
	/// <typeparam name="TBuilder">The concrete type of the builder class. This self-referencing generic type parameter
	/// allows us to define behaviour in this base class that returns an instance of the concrete builder type.</typeparam>
	public abstract class BuilderBase<TObject,TBuilder> : IGenerator<TObject> 
		where TBuilder : BuilderBase<TObject,TBuilder>, new()
	{
		/// <summary>
		/// Changes the current builder and returns it - also returns the builder, reduces amount of code needed for
		/// create builder implementations that use chainable methods for specifying how objects will be built
		/// </summary>
		/// <returns>The current builder instance</returns>
		protected TBuilder Change(Action<TBuilder> modify)
		{
			modify((TBuilder)this);
			return (TBuilder)this;
		}

		/// <summary>
		/// Creates a copy of the current builder. The values of any fields and properties of type IGenerator
		/// are copied to the new instance. The modify function is invoked upon the new instance and the instance
		/// is returned. Reducing amount of code needed to create builder implementations that use chainable 
		/// methods to modify values used to build objects.
		/// </summary>
		/// <returns>The current builder instance</returns>
		protected TBuilder Copy(Action<TBuilder> modify)
		{
			// Create a copy with copies of fields and properties belonging to the current instance
			var copy = new TBuilder();

			// TODO - one-time creation and caching of get / set delegates
			var properties = GetType().GetProperties(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
			foreach(var property in properties)
			{
				var value = property.GetValue(this, null);
				property.SetValue(copy, value, null);
			}
			var fields = GetType().GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
			foreach (var field in fields)
			{
				if(!field.IsInitOnly)
				{
					var value = field.GetValue(this);
					field.SetValue(copy, value);
				}
			}

			modify(copy);
			return copy;
		}

		protected abstract IGenerator<TObject> GetGenerator();
 
		public IEnumerable<TObject> Build()
		{
			return GetGenerator().Build();
		}

		IEnumerable IGenerator.Build()
		{
			return Build();
		}

	}
}