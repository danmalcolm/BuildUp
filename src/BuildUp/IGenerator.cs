using System;
using System.Collections;
using System.Collections.Generic;

namespace BuildUp
{
	/// <summary>
	/// Generates a sequence of objects suitable for unit testing, test data generation etc
	/// </summary>
	public interface IGenerator
	{
		IEnumerable Build();
	}

	/// <summary>
	/// Generates a sequence of objects suitable for unit testing, test data generation etc
	/// </summary>
	/// <typeparam name="TObject"></typeparam>
	public interface IGenerator<out TObject> : IGenerator
	{
		/// <summary>
		/// Creates and returns the sequence of objects that this generator has been set up to build
		/// </summary>
		/// <returns></returns>
		new IEnumerable<TObject> Build();
		
		/// <summary>
		/// Creates a new generator that modifies the sequence of objects by invoking a function against each object generated by
		/// this generator
		/// </summary>
		/// <param name="selector"></param>
		/// <returns></returns>
		IGenerator<TResult> Select<TResult>(Func<TObject,TResult> selector);

		/// <summary>
		/// Creates a new generator that modifies each object generated by this generator by executing the specified action.
		/// Intended for actions that mutate the objects
		/// </summary>
		/// <param name="action"></param>
		/// <returns></returns>
		IGenerator<TObject> Select(Action<TObject> action);
				
		/// <summary>
		/// Creates a new generator that combines objects built by the current generator with those generated by another,
		/// and returns the result of invoking the specified function against each pair of objects. The size of the 
		/// resulting sequence will be limited to the length of the shortest sequence.
		/// </summary>
		/// <typeparam name="TChild"></typeparam>
		/// <typeparam name="TResult"></typeparam>
		/// <param name="sequenceSelector"></param>
		/// <param name="resultSelector"></param>
		/// <returns></returns>
		IGenerator<TResult> SelectMany<TChild, TResult>(Func<IGenerator<TObject>, IGenerator<TChild>> sequenceSelector, Func<TObject, TChild, TResult> resultSelector);

		/// <summary>
		/// Creates a new generator that combines objects built by the current generator with those generated by another, then
		/// invokes the specified action on each pair of objects.
		/// </summary>
		/// <typeparam name="TChild"></typeparam>
		/// <param name="childSequenceSelector"></param>
		/// <param name="modify"></param>
		/// <returns></returns>
		IGenerator<TObject> SelectMany<TChild>(Func<IGenerator<TObject>, IGenerator<TChild>> childSequenceSelector, Action<TObject, TChild> modify);

		/// <summary>
		/// Creates a new generator using the supplied function to modify the order of the objects in the sequence generated by this generator.
		/// This is intended to support changes in the sequence of objects, e.g. repeating, looping and shuffling, the
		/// the actual objects themselves should not be changed. Note that IGenerator returns an infinite sequence so
		/// operations like Reverse or ToArray should not be applied directly to the generator sequences. Try Take first.
		/// </summary>
		/// <param name="modify"></param>
		/// <returns></returns>
		IGenerator<TObject> ModifySequence(Func<IEnumerable<object>, IEnumerable<object>> modify);

	}
}