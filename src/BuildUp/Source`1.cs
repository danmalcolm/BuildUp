using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace BuildUp
{
	/// <summary>
	/// ISource implementation
	/// </summary>
	/// <typeparam name="TObject"></typeparam>
	public class Source<TObject> : ISource<TObject>
	{
		private readonly ChildSourceCollection childSources;

		/// <summary>
		/// The function that creates the objects generated by this source
		/// </summary>
		private readonly Func<CreateContext, TObject> create;

		/// <summary>
		/// A function used to modify the sequence of objects as they are generated
		/// </summary>
		private readonly Func<IEnumerable<object>, IEnumerable<object>> modifySequence;

		public Source(ChildSourceCollection childSources, Func<CreateContext, TObject> create, Func<IEnumerable<object>, IEnumerable<object>> modifySequence = null)
		{
			this.childSources = childSources;
			this.create = create;
			this.modifySequence = modifySequence ?? (x => x);
		}
		
		public IEnumerable<TObject> Build()
		{
			// Generate the sequence
			var contexts = childSources.Tuplize().Select((tuple, index) => new CreateContext(index, tuple));
			var sequence = contexts.Select(x => create(x));
			// Modify the sequence
			return modifySequence(sequence.Cast<object>()).Cast<TObject>();
		}

		IEnumerable ISource.Build()
		{
			return Build();
		}

		#region Select, SelectMany

		public ISource<TResult> Select<TResult>(Func<TObject, TResult> selector)
		{
			return new Source<TResult>(childSources, @base => selector(this.create(@base)), modifySequence);
		}

		public ISource<TObject> Select(Action<TObject> action)
		{
			return Select(instance =>
			{
				action(instance);
				return instance;
			});
		}

		public ISource<TResult> SelectMany<TChild, TResult>(Func<ISource<TObject>, ISource<TChild>> sourceSelector, Func<TObject, TChild, TResult> resultSelector)
		{
			var newSource = sourceSelector(this);
			// combine other source with current child sources
			var newChildSources = childSources.Add(newSource);
			int newSourceIndex = newChildSources.Count - 1;
			// Create new source with combined sources plus a function that first invokes this source's create function,
			// then invokes the new create function on the result, together with the value from the other source
			Func<CreateContext, TResult> newCreate = context => resultSelector(create(context), (TChild) context.ChildSourceValues[newSourceIndex]);

			return new Source<TResult>(newChildSources, newCreate, modifySequence);
		}

		public ISource<TObject> SelectMany<TCollection>(Func<ISource<TObject>, ISource<TCollection>> childSequenceSelector, Action<TObject, TCollection> modify)
		{
			return SelectMany(childSequenceSelector, (a, b) =>
			{
				modify(a, b);
				return a;
			});
		}

		public ISource<TObject> ModifySequence(Func<IEnumerable<object>, IEnumerable<object>> modify)
		{
			Func<IEnumerable<object>, IEnumerable<object>> newSequenceModifier = x => modify(modifySequence(x));
			return new Source<TObject>(childSources, create, newSequenceModifier);
		}

		#endregion

		/// <summary>
		/// Creates a copy of this source using a different collection of child sources
		/// </summary>
		/// <param name="modify"></param>
		/// <returns></returns>
		public Source<TObject> ModifyChildSources(Func<ChildSourceCollection, ChildSourceCollection> modify)
		{
			var newChildSources = modify(childSources);
			return new Source<TObject>(newChildSources, create, modifySequence);
		}

	}
}