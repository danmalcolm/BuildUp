using System;
using System.Collections.Generic;
using System.Linq;

namespace BuildUp
{
	/// <summary>
	/// Contains convenience extension methods for accessing the sequence of objects generated by a generator
	/// </summary>
	public static class SequenceAccessExtensions
	{
		/// <summary>
		/// Shortcut method that returns the specified number of objects generated by the generator, equivalent to generator.Build().Take(...)
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="generator"></param>
		/// <param name="count"></param>
		/// <returns></returns>
		public static IEnumerable<T> Take<T>(this IGenerator<T> generator, int count)
		{
			return generator.Build().Take(count);
		}

		/// <summary>
		/// Shortcut method that returns the first object generated by the generator, equivalent to generator.Build().First()
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="generator"></param>
		/// <returns></returns>
		public static T First<T>(this IGenerator<T> generator)
		{
			return generator.Build().First();
		}

		/// <summary>
		/// Creates a new generator that generates an infinite sequence, repeating the first object generated by the current generator
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="generator"></param>
		/// <returns></returns>
		public static IGenerator<T> Freeze<T>(this IGenerator<T> generator)
		{
			bool first = true;
			T result = default(T);
			return generator.Select(value =>
			{
				if(first)
				{
					result = value;
					first = false;
				}
				return result;
			});
		}	

		/// <summary>
		/// Stores the specified number of elements from the start of the current sequence and creates
		/// an infinite sequence that loops repeatedly over the stored items. 
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="generator"></param>
		/// <param name="count"></param>
		/// <returns></returns>
		public static IGenerator<T> Loop<T>(this IGenerator<T> generator, int count)
		{
			return generator.ModifySequence(x => LoopInternal(x, count));
		}

		private static IEnumerable<object> LoopInternal(IEnumerable<object> sequence, int count)
		{
			var values = sequence.Take(count).ToArray();
			if(values.Length > 0)
			{
				int index = 0;
				while(true)
				{
					yield return values[index];
					index = index < values.Length - 1 ? index + 1 : 0;
				}
			}
		}
	}
}