using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

namespace BuildUp
{
	/// <summary>
	/// Base class for typical *Builder classes (CustomerBuilder, OrderBuilder) that allow test code to vary values used
	/// to create the objects via chainable methods, e.g. new OrderBuilder().WithCustomer( ...). In some projects, builder 
	/// classes will be the most suitable place to locate methods that are used to vary parameters used to construct the objects.
	/// This base class provides some convenience methods to make these chainable methods simple to write. It includes helper
	/// methods to support both mutable and immutable builders.
	/// </summary>
	/// <typeparam name="TObject">The type of object generated by the builder</typeparam>
	/// <typeparam name="TBuilder">The concrete type of the builder class. This self-referencing generic type parameter
	/// allows code in the base class to &quot;know&quot; its concrete type, which makes it possible to create shared
	/// convenience methods that return instances of the concrete builder type.</typeparam>
	public abstract class BuilderBase<TObject,TBuilder> : IGenerator<TObject> 
		where TBuilder : BuilderBase<TObject,TBuilder>, new()
	{
		/// <summary>
		/// Modifies the current instance using the supplied function and returns it. Can be used to reduce the amount
		/// of code needed to add chainable set-up methods to mutable builder implementations.
		/// </summary>
		/// <example>
		/// <code> 
		/// public class BookingBuilder : BuilderBase&lt;Booking, BookingBuilder&gt;
		///	{
		///		private IGenerator&lt;Hotel&gt; hotels = new HotelBuilder();
		///		private IGenerator&lt;DateTime&gt; startDates = DateTimeGenerators.IncrementingDays(new DateTime(2012, 1, 1));
		///
		///		// ...
		///
		///		public BookingBuilder AtHotel(IGenerator&lt;Hotel&gt; hotels)
		///		{
		///			return Change(me => me.hotels = hotels);
		///		}
		/// 
		///		// ...
		/// }
		/// </code>
		/// </example>
		/// <returns>The current builder instance</returns>
		protected TBuilder Change(Action<TBuilder> modify)
		{
			modify((TBuilder)this);
			return (TBuilder)this;
		}

		/// <summary>
		/// Creates and returns a modified copy of the current builder. The values of any fields and properties 
		/// on the current instance are copied to the new instance, after which the specified function is invoked
		/// to modify the new instance. Can be used to reduce the amount of code needed to add chainable set-up methods to 
		/// immutable builder implementations.
		/// </summary>
		/// <returns>A copy of the current builder instance</returns>
		protected TBuilder Copy(Action<TBuilder> modify)
		{
			// Create a copy with copies of fields and properties belonging to the current instance
			var copy = new TBuilder();

			// TODO - one-time creation and caching of get / set delegates
			var properties = GetType().GetProperties(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
			foreach(var property in properties)
			{
				var value = property.GetValue(this, null);
				property.SetValue(copy, value, null);
			}
			var fields = GetType().GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
			foreach (var field in fields)
			{
				if(!field.IsInitOnly)
				{
					var value = field.GetValue(this);
					field.SetValue(copy, value);
				}
			}

			modify(copy);
			return copy;
		}

		protected abstract IGenerator<TObject> GetGenerator();
 
		public IEnumerable<TObject> Build()
		{
			return GetGenerator().Build();
		}

		IEnumerable IGenerator.Build()
		{
			return Build();
		}

	}
}