using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using BuildUp.Utility.Reflection;

namespace BuildUp.Generators
{
	public static class GeneratorExtensions
	{
		/// <summary>
		/// Creates a new generator that converts the sequence generated by the current generator using
		/// the specified function.
		/// </summary>
		/// <param name="generator"> </param>
		/// <param name="selector"></param>
		/// <returns></returns>
		public static IGenerator<TResult> Select<TObject, TResult>(this IGenerator<TObject> generator, Func<TObject, TResult> selector)
		{
			return Generator.Sequence(() => generator.Build().Select(selector));
		}

		/// <summary>
		/// Creates a new generator that modifies each object generated by the current generator using the specified action.
		/// Intended for actions that mutate the objects in-place.
		/// </summary>
		/// <param name="generator"> </param>
		/// <param name="action"></param>
		/// <returns></returns>
		public static IGenerator<TObject> Modify<TObject>(this IGenerator<TObject> generator, Action<TObject> action)
		{
			return generator.Select(x =>
			{
				action(x);
				return x;
			});
		}

	    /// <summary>
	    /// Creates a new generator that modifies each object generated by the current generator using the specified action together with the values from a second generator.
	    /// Intended for actions that mutate the objects in-place.
	    /// </summary>
	    /// <param name="generator"> </param>
	    /// <param name="other"> </param>
	    /// <param name="action"></param>
	    /// <returns></returns>
	    public static IGenerator<TObject> Modify<TObject,TOther>(this IGenerator<TObject> generator,  IGenerator<TOther> other, Action<TObject,TOther> action)
        {
            Func<TObject,TOther,TObject> select = (TObject value1, TOther value2) =>
            {
                action(value1, value2);
                return value1;
            };
	        return generator.Combine(other, select);
        }

        /// <summary>
        /// Creates a new generator that combines objects built by the current generator with those generated by another,
        /// and creates a new sequence from the result of invoking the specified function against each pair of objects. 
        /// IGenerator's version of Enumerable.Zip. The result will generate a sequence with the length of the shortest
        /// generator.
        /// </summary>
        /// <typeparam name="TObject"></typeparam>
        /// <typeparam name="TOther"></typeparam>
        /// <typeparam name="TResult"></typeparam>
        /// <param name="generator"></param>
        /// <param name="other"></param>
        /// <param name="get"></param>
        /// <returns></returns>
	    public static IGenerator<TResult> Combine<TObject, TOther, TResult>(this IGenerator<TObject> generator, IGenerator<TOther> other, Func<TObject,TOther,TResult> get)
	    {
	        return Generator.Sequence(() => Enumerable.Zip(generator.Build(), other.Build(), get));
	    }

	    /// <summary>
        /// Creates a new generator that combines objects built by the current generator with those generated by another,
        /// and creates a new sequence from the result of invoking the specified function against each pair of objects. 
        /// The generated sequence will be length of the shortest sequence generated by either generator. This is similar 
        /// in behaviour to Combine method and is intended to support LINQ query comprehension syntax.
		/// </summary>
		/// <typeparam name="TObject"></typeparam>
		/// <typeparam name="TChild"></typeparam>
		/// <typeparam name="TResult"></typeparam>
		/// <param name="generator"></param>
		/// <param name="generatorSelector"></param>
		/// <param name="resultSelector"></param>
		/// <returns></returns>
		public static IGenerator<TResult> SelectMany<TObject, TChild, TResult>(this IGenerator<TObject> generator, Func<IGenerator<TObject>, IGenerator<TChild>> generatorSelector, Func<TObject, TChild, TResult> resultSelector)
		{
			var other = generatorSelector(generator);
			return generator.Combine(other, resultSelector);
		}

	    /// <summary>
		/// Creates a new generator that combines objects built by the current generator with those generated by another, then
		/// invokes the specified action on each pair of objects.
		/// </summary>
		/// <typeparam name="TResult"></typeparam>
		/// <typeparam name="TObject"> </typeparam>
		/// <param name="generator"> </param>
		/// <param name="childSequenceSelector"></param>
		/// <param name="modify"></param>
		/// <returns></returns>
		public static IGenerator<TObject> SelectMany<TObject,TResult>(this IGenerator<TObject> generator, Func<IGenerator<TObject>, IGenerator<TResult>> childSequenceSelector, Action<TObject, TResult> modify)
		{
			return generator.SelectMany(childSequenceSelector, (a, b) =>
			{
				modify(a, b);
				return a;
			});
		}

	    /// <summary>
		/// Returns a new generator that takes each object generated by the current generator and sets 
		/// the member specified by the expression to a given value
		/// </summary>
		/// <typeparam name="TObject"></typeparam>
		/// <typeparam name="TMember"></typeparam>
		/// <param name="generator"></param>
		/// <param name="expression"></param>
		/// <param name="value"></param>
		/// <returns></returns>
		public static IGenerator<TObject> Set<TObject,TMember>(this IGenerator<TObject> generator, Expression<Func<TObject,TMember>> expression, TMember value)
		{
			var accessor = MemberAccessor.For(expression);
			Action<TObject> set = x => accessor.SetValue(x, value);
			return generator.Modify(set);
		}

	    /// <summary>
		/// Returns a new generator that takes each object generated by the current generator and sets 
		/// the member specified by the expression to a value supplied by a different generator
		/// </summary>
		/// <typeparam name="TObject"></typeparam>
		/// <typeparam name="TMember"></typeparam>
		/// <param name="generator"></param>
		/// <param name="expression"></param>
		/// <param name="values"></param>
		/// <returns></returns>
		public static IGenerator<TObject> Set<TObject, TMember>(this IGenerator<TObject> generator, Expression<Func<TObject, TMember>> expression, IGenerator<TMember> values)
		{
			var accessor = MemberAccessor.For(expression);
			return generator.SelectMany(s => values, (@object, value) => accessor.SetValue(@object, value));
		}

        /// <summary>
        /// Returns a new generator that builds a sequence of sequences containing objects generated 
        /// by the current generator. This is designed to generate values that will be used to 
        /// populate lists of objects.
        /// </summary>
        /// <typeparam name="TObject"></typeparam>
        /// <param name="generator"></param>
        /// <param name="length">A value specifying the length of each collection</param>
        /// <returns></returns>
        public static IGenerator<IEnumerable<TObject>> SequencesOf<TObject>(this IGenerator<TObject> generator,
            int length)
        {
            return Generator.Sequence(() => GroupsOfImpl(generator, Generator.Constant(length)));
        }

	    /// <summary>
	    /// Returns a new generator that builds a sequence of sequences containing objects generated 
	    /// by the current generator. This is designed to generate values that will be used to 
	    /// populate lists of objects.
	    /// </summary>
	    /// <typeparam name="TObject"></typeparam>
	    /// <param name="generator"></param>
	    /// <param name="lengths">A generator specifying the length of each collection</param>
	    /// <returns></returns>
	    public static IGenerator<IEnumerable<TObject>> SequencesOf<TObject>(this IGenerator<TObject> generator, IGenerator<int> lengths)
	    {
	        return Generator.Sequence(() => GroupsOfImpl(generator, lengths));
	    }

        private static IEnumerable<IEnumerable<TObject>> GroupsOfImpl<TObject>(IGenerator<TObject> generator, IGenerator<int> lengths)
        {
            var e = generator.Build().GetEnumerator();
            foreach (var length in lengths.Build())
            {
                var collection = new List<TObject>();
                int count = 0;
                while (count < length && e.MoveNext())
                {
                    collection.Add(e.Current);
                    count++;
                }
                yield return collection;
            }
        }
	}
}