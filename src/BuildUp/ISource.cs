using System;
using System.Collections;
using System.Collections.Generic;

namespace BuildUp
{
	/// <summary>
	/// Generates a sequence of objects suitable for unit testing, test data generation etc
	/// </summary>
	public interface ISource
	{
		IEnumerable Build();
	}

	/// <summary>
	/// Generates a sequence of objects suitable for unit testing, test data generation etc
	/// </summary>
	/// <typeparam name="TObject"></typeparam>
	public interface ISource<out TObject> : ISource
	{
		/// <summary>
		/// Creates and returns the sequence of objects that this source has been set up to build
		/// </summary>
		/// <returns></returns>
		new IEnumerable<TObject> Build();
		
		/// <summary>
		/// Creates a new source that modifies the sequence of objects by invoking a function against each object generated by
		/// this source
		/// </summary>
		/// <param name="selector"></param>
		/// <returns></returns>
		ISource<TResult> Select<TResult>(Func<TObject,TResult> selector);

		/// <summary>
		/// Creates a new source that modifies each object generated by this source by executing the specified action.
		/// Intended for actions that mutate the objects
		/// </summary>
		/// <param name="action"></param>
		/// <returns></returns>
		ISource<TObject> Select(Action<TObject> action);
				
		/// <summary>
		/// Creates a new source that combines objects built by the current source with those generated by another,
		/// and returns the result of invoking the specified function against each pair of objects. The size of the 
		/// resulting sequence will be limited to the length of the shortest sequence.
		/// </summary>
		/// <typeparam name="TChild"></typeparam>
		/// <typeparam name="TResult"></typeparam>
		/// <param name="sequenceSelector"></param>
		/// <param name="resultSelector"></param>
		/// <returns></returns>
		ISource<TResult> SelectMany<TChild, TResult>(Func<ISource<TObject>, ISource<TChild>> sequenceSelector, Func<TObject, TChild, TResult> resultSelector);

		/// <summary>
		/// Creates a new source that combines objects built by the current source with those generated by another, then
		/// invokes the specified action on each pair of objects.
		/// </summary>
		/// <typeparam name="TChild"></typeparam>
		/// <param name="childSequenceSelector"></param>
		/// <param name="modify"></param>
		/// <returns></returns>
		ISource<TObject> SelectMany<TChild>(Func<ISource<TObject>, ISource<TChild>> childSequenceSelector, Action<TObject, TChild> modify);

		/// <summary>
		/// Creates a new source using the supplied function to modify the order of the objects in the sequence generated by this source.
		/// This is intended to support changes in the sequence of objects, e.g. repeating, looping and shuffling, the
		/// the actual objects themselves should not be changed. Note that ISource returns an infinite sequence so
		/// operations like Reverse or ToArray should not be applied directly to the source sequences. Try Take first.
		/// </summary>
		/// <param name="modify"></param>
		/// <returns></returns>
		ISource<TObject> ModifySequence(Func<IEnumerable<object>, IEnumerable<object>> modify);

	}
}